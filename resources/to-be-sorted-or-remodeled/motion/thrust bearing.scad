/*
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* 
 * This program is a parametric thrust bearing race generator.
 * To make an actual thrust bearing with this, sandwich the bb's
 * in the generated raceway between 2 washers. 
 * The section on physical measurements allows you to change
 * all the physical dimensions for your thrust bearing race.
 * Features:
 *	1) option to have either a set number of bb's or autogenerated based on:
 *		- bb diameter
 * 		- minimum plastic between bb's
 *		- radius of race for that row of bb's
 *	2) option to have multiple rings/rows of bb's starting from the inside
 *		This may make a dimensionally compressed rows if the number of rows is
 *		between X.866 and (X+1). 
 *	3) option to set center radius of the race to:
 *		- minimum distance (inner radius + minimum plastic surround + bb radius)
 *		- maximum distance (outer radius - (minimum plastic surround+bb radius))
 *		- average distance ((inner radius + outer radius)/2)
 *		- user specified distance
 *	4) option to produce a model with NxM races (useful for printing sets 
 *		of thrust bearings for a CNC router or a 3D printer)
 *
 * To use the features, look for the keyword OPTION
 * 
 * HINTS:
 *	- the typical crossman bb is 4.3 mm, so I use a 3/16 inch drill bit to clean out the holes
 *	- I use fender washers since they're larger and can hold the bbs easier.

comments pasted from thingiverse:

These bb race cages can be either 3D printed or cut on a CNC router, mill, etc. If you use a 3D printer, you may want to determine the slop in your print by first printing a single race cage and taking the ID/OD bb measurements and updating the slop in the OpenSCAD file.

To create a thrust bearing using this thing, you will also need 2 matched washers of the ID/OD appropriate for your application, a supply of ball bearings, and some tape.

1) Determine the ID/OD of your bearing, any printer slop, ball bearing spacing and ball bearing diameter (I used 4.3 mm bb's from and air rifle). 2) Adjust the number of copies for your application. 3) Print or cut the generated model. 4) If 3D printing, use appropriate sized drill bits for any cleanup of the interior shaft hole and bb holes. I used a 3/8ths drill for my shaft clean up and a 3/16ths for my bb cleanup. 5) Lay 2 stips of tape face up on your work space. 6) Lay the first washer on top of the tape. Make sure not to block the center hole with tape. 7) Lay one of the printed race cages on the washer and fill bb holes with bb's. 8) Carefully place the 2nd washer on top of the bb's and gently wrap the ends of the tape over the top washer. Don't block the holes. 9) Place the thrust bearing in your application and firmly secure it in place. 10) Carefully cut the tape and remove with needle nose pliers. 11) Repeat

Features: 1) option to have either a set number of bb's or autogenerated based on:

- bb diameter
- minimum plastic between bb's
- radius of race for that row of bb's
2) option to have multiple rings/rows of bb's starting from the inside

-This may make a dimensionally compressed rows if the number of rows is
    between X.866 and (X+1). 
3) option to set race radius to:

- minimum distance (inner radius + minimum plastic surround + bb radius)
- maximum distance (outer radius - (minimum plastic surround+bb radius))
- average distance ((inner radius + outer radius)/2)
- user specified distance
4) option to produce a model with NxM races (useful for printing sets

of thrust bearings for a CNC router or a 3D printer)
Tips: Use typical metal crossman 4.3mm bb's for metal washers. Use airsoft bb's for metal or plastic washers Use fender washers for multiple rows of bb's.

 */


//Physical measurement inputs

bb_diam_base=4.4;// nominal diameter of bb
inner_diam_base = 25.4 *3.0/8.0;// inner cage diameter
outer_diam_base = 25.4 *5.0/4.0; // outer cage diameter
surround_min=4;// minimum distance around bb in race
// measured slop for your printing/cutting method
bb_diam_slop=0.4;
inner_diam_slop=0.4;
outer_diam_slop=-0.4;

// spaces between copies in mm
copy_space_x=4;
copy_space_y=4;

//OPTION: NUMBER OF COPIES
// number of copies of race in x and y
num_x=2;// set to number of copies in x
num_y=3;// set to number of copies in y

// Derived dimensions
bb_diam=bb_diam_base + bb_diam_slop;
bb_radius=bb_diam/2;
inner_diam = inner_diam_base+inner_diam_slop;
inner_radius = inner_diam / 2;
outer_diam = outer_diam_base+outer_diam_slop;
outer_radius = outer_diam / 2;

race_width = bb_diam + (2*surround_min); // width of race
race_height = bb_diam_base - 2.0;// thickness of race
race_IR=inner_radius;
race_OR=outer_radius;

// OPTION: DEFAULT NUMBER OF ROWS OF BBs
// 	YOU CAN CHANGE THIS TO A FIXED NUMBER
n_rows=1;

// Max Radius Race
race_R_max=race_OR-(surround_min+(bb_diam_base/2));

// Centered race
race_R_ave=(inner_diam_base+outer_diam_base)/4;

// Min Radius Race 
race_R_min=race_IR+surround_min+(bb_diam_base/2);
// OPTION: MULTIPLE DYNAMIC ROWS OF BBs
// USE THIS ONLY WITH MINIMUM RADIUS OR YOU MAY 
//	GET SERIOUSLY WEIRD RESULTS
// uncomment next line to allow multiple rows for Min Radius Race
n_rows = max(1,(((outer_diam_base-inner_diam_base)/2.0)-surround_min)/(bb_diam_base+surround_min));
n_rows_rem=n_rows-floor(n_rows);
race_CR_last=floor(n_rows-1)*(bb_diam_base+surround_min)+race_R_min;//radius of last full row
race_CR_max=(outer_diam_base-bb_diam_base- 2*surround_min)/2;// radius of last row

// OPTION: SET RADIUS
//	COMMENT OUT ALL BUT THE ONE YOU CHOOSE TO USE
// set radius to minimum of min or average
race_CR=min(race_R_ave,race_R_min);
// set radius to minimum of max or average
// race_CR=max(race_R_ave, race_R_max);
// set radius to average
// race_CR=race_R_ave;
// set radius to user specified
// race_CR=8;// change this to your application needs.


echo ("Race Data:");
echo ("               ID ", race_IR*2, " ", race_IR*2/25.4);
echo ("               OD ", race_OR*2, " ",race_OR*2/25.4);
echo ("               CD ", race_CR*2, " ",race_CR*2/25.4);
echo ("               num rows ", n_rows);

for (race_numx=[0:(num_x-1)]){
for (race_numy=[0:(num_y-1)]){
translate( [(race_numx*race_OR*2.1),
		(race_numy*race_OR*2.1),0]){
echo("Copy number: race_numx ", race_numx," race_numy ", race_numy);
difference() {
    // outer race
    cylinder ( r = race_OR, h = race_height, center = true,$fn=50 );
    // inner race
    cylinder ( r = race_IR, h = race_height + 2, center = true,$fn=50 );

	for (row_num =[1:n_rows]){
		assign(race_CR_tmp=race_CR+(row_num-1)*(bb_diam+surround_min))
		{
//OPTION: NUMBER OF BBs PER ROW  - ALSO SET THIS FOR THE NEXT LOOP
		// if you want a constant number of bbs change the next line to not be dynamic
		assign(num_bbs=floor( (2*3.14159265*race_CR_tmp) / (bb_diam+surround_min) )){
//		assign(num_bbs=8){
			for (bb_num=[1 : 1:num_bbs]) {
				assign(ndeg=360.0/num_bbs ){
				// bb hole
				rotate ( [0, 0, ndeg * bb_num]){
					translate ( [race_CR_tmp, 0, 0]) {
						cylinder ( r = bb_radius, h = bb_diam, center = true,$fn=30);
					}
				}
				}
			}
		}
		}
	}
	if ((n_rows > 1)&&(n_rows_rem > 0.8) && (n_rows_rem < 1)){
//OPTION: NUMBER OF BBs PER ROW
		// if you want a constant number of bbs change the next line to not be dynamic
		assign(num_bbs=floor( (2*3.14159265*race_CR_last) / (bb_diam+surround_min) )){
//		assign(num_bbs=8){
		for (bb_num=[1 : num_bbs]) {
		assign(ndeg=360.0/num_bbs ){
		  // bb hole
		   rotate ( [0, 0, ndeg * (bb_num+0.5)]){
		  	translate ( [race_CR_max , 0, 0]) {
		  		cylinder ( r = bb_radius, h = bb_diam, center = true,$fn=30);
		   	}
		   }
			}
		}
		}
      }
}
}// end loop translate
}//end loop y
}//end loop x